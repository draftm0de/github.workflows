name: git-tag-builder
description: Create git tags based on version and target branch with optional branch-level tagging

inputs:
  version:
    description: "Version to tag (e.g., v1.2.12, 1.2.12)"
    required: true
  target-branch:
    description: "Target branch name (e.g., main, v1.2, develop)"
    required: true
  enable-branch-tag:
    description: "Enable branch-level tagging when branch name is version-like (default: true)"
    required: false
    default: 'true'
  git-tag-levels:
    description: "Comma-separated tag levels to create: patch, minor, major (e.g., 'patch,minor,major'). Filters out levels already covered by version-like branches. Never includes 'latest'."
    required: false
    default: 'patch'

outputs:
  git-tags:
    description: "List of git tags created (space-separated)"
    value: ${{ steps.tag.outputs.git_tags }}
  exact-tag:
    description: "Exact version tag created (e.g., v1.2.12)"
    value: ${{ steps.tag.outputs.exact_tag }}
  branch-tag:
    description: "Branch-level tag created (e.g., v1.2), empty if not created"
    value: ${{ steps.tag.outputs.branch_tag }}

runs:
  using: "composite"
  steps:
    - name: Parse version and create tags
      id: tag
      shell: bash
      run: |
        set -euo pipefail

        VERSION="${{ inputs.version }}"
        TARGET_BRANCH="${{ inputs.target-branch }}"
        ENABLE_BRANCH_TAG="${{ inputs.enable-branch-tag }}"
        TAG_LEVELS="${{ inputs.git-tag-levels }}"

        # Validate version format
        if [[ ! "$VERSION" =~ ^([vV]?)([0-9]+)\.([0-9]+)\.([0-9]+)(\+.+)?$ ]]; then
          echo "::error::Invalid version format: $VERSION"
          echo "::error::Expected format: [v]X.Y.Z[+postfix]"
          exit 1
        fi

        PREFIX="${BASH_REMATCH[1]}"
        MAJOR="${BASH_REMATCH[2]}"
        MINOR="${BASH_REMATCH[3]}"
        PATCH="${BASH_REMATCH[4]}"
        POSTFIX="${BASH_REMATCH[5]}"

        # Strip postfix for tagging (git tags should be clean semver)
        EXACT_TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"

        echo "::notice::Calculated exact version tag: $EXACT_TAG"

        # Check if exact version tag already exists
        if git rev-parse "$EXACT_TAG" >/dev/null 2>&1; then
          echo "::error::Tag $EXACT_TAG already exists"
          exit 1
        fi

        TAGS_CREATED="$EXACT_TAG"

        # Determine which levels are already covered by branch tags
        BRANCH_COVERS_MAJOR="false"
        BRANCH_COVERS_MINOR="false"

        if [[ "$ENABLE_BRANCH_TAG" == "true" ]]; then
          if [[ "$TARGET_BRANCH" =~ ^([vV]?)([0-9]+)\.([0-9]+)$ ]]; then
            BRANCH_MAJOR="${BASH_REMATCH[2]}"
            BRANCH_MINOR="${BASH_REMATCH[3]}"
            if [ "$BRANCH_MAJOR" == "$MAJOR" ] && [ "$BRANCH_MINOR" == "$MINOR" ]; then
              BRANCH_COVERS_MAJOR="true"
              BRANCH_COVERS_MINOR="true"
            fi
          elif [[ "$TARGET_BRANCH" =~ ^([vV]?)([0-9]+)$ ]]; then
            BRANCH_MAJOR="${BASH_REMATCH[2]}"
            if [ "$BRANCH_MAJOR" == "$MAJOR" ]; then
              BRANCH_COVERS_MAJOR="true"
            fi
          fi
        fi

        # Create multi-level tags based on git-tag-levels input
        IFS=',' read -ra LEVELS <<< "$TAG_LEVELS"
        for level in "${LEVELS[@]}"; do
          level=$(echo "$level" | xargs)
          case "$level" in
            patch)
              # Patch is always the exact tag, already added
              ;;
            minor)
              # Only add minor tag if not covered by branch
              if [ "$BRANCH_COVERS_MINOR" == "false" ]; then
                MINOR_TAG="${PREFIX}${MAJOR}.${MINOR}"
                if git rev-parse "$MINOR_TAG" >/dev/null 2>&1; then
                  echo "::notice::Minor tag $MINOR_TAG already exists (will be updated when pushed)"
                fi
                TAGS_CREATED="$TAGS_CREATED $MINOR_TAG"
                echo "::notice::Calculated minor-level tag: $MINOR_TAG"
              else
                echo "::notice::Skipping minor tag (covered by branch tag)"
              fi
              ;;
            major)
              # Only add major tag if not covered by branch
              if [ "$BRANCH_COVERS_MAJOR" == "false" ]; then
                MAJOR_TAG="${PREFIX}${MAJOR}"
                if git rev-parse "$MAJOR_TAG" >/dev/null 2>&1; then
                  echo "::notice::Major tag $MAJOR_TAG already exists (will be updated when pushed)"
                fi
                TAGS_CREATED="$TAGS_CREATED $MAJOR_TAG"
                echo "::notice::Calculated major-level tag: $MAJOR_TAG"
              else
                echo "::notice::Skipping major tag (covered by branch tag)"
              fi
              ;;
            *)
              echo "::error::Unknown tag level '$level' (valid: patch, minor, major)"
              exit 1
              ;;
          esac
        done

        # Determine if we should create a branch-level tag
        BRANCH_TAG=""
        if [[ "$ENABLE_BRANCH_TAG" == "true" ]]; then
          # Check if target branch name is version-like (e.g., v1.2, 1.2, v1)
          if [[ "$TARGET_BRANCH" =~ ^([vV]?)([0-9]+)\.([0-9]+)$ ]]; then
            # Branch is major.minor format (e.g., v1.2)
            BRANCH_PREFIX="${BASH_REMATCH[1]}"
            BRANCH_MAJOR="${BASH_REMATCH[2]}"
            BRANCH_MINOR="${BASH_REMATCH[3]}"
            BRANCH_TAG="${BRANCH_PREFIX}${BRANCH_MAJOR}.${BRANCH_MINOR}"

            # Only include branch tag if it matches current version's major.minor
            if [ "$BRANCH_MAJOR" == "$MAJOR" ] && [ "$BRANCH_MINOR" == "$MINOR" ]; then
              echo "::notice::Calculated branch-level tag: $BRANCH_TAG"

              # Note if existing branch tag will be updated
              if git rev-parse "$BRANCH_TAG" >/dev/null 2>&1; then
                echo "::notice::Branch tag $BRANCH_TAG already exists (will be updated when pushed)"
              fi

              TAGS_CREATED="$TAGS_CREATED $BRANCH_TAG"
            else
              echo "::notice::Branch version ($BRANCH_MAJOR.$BRANCH_MINOR) does not match current version ($MAJOR.$MINOR), skipping branch tag"
            fi
          elif [[ "$TARGET_BRANCH" =~ ^([vV]?)([0-9]+)$ ]]; then
            # Branch is major-only format (e.g., v1)
            BRANCH_PREFIX="${BASH_REMATCH[1]}"
            BRANCH_MAJOR="${BASH_REMATCH[2]}"
            BRANCH_TAG="${BRANCH_PREFIX}${BRANCH_MAJOR}"

            # Only include branch tag if it matches current version's major
            if [ "$BRANCH_MAJOR" == "$MAJOR" ]; then
              echo "::notice::Calculated branch-level tag: $BRANCH_TAG"

              # Note if existing branch tag will be updated
              if git rev-parse "$BRANCH_TAG" >/dev/null 2>&1; then
                echo "::notice::Branch tag $BRANCH_TAG already exists (will be updated when pushed)"
              fi

              TAGS_CREATED="$TAGS_CREATED $BRANCH_TAG"
            else
              echo "::notice::Branch version ($BRANCH_MAJOR) does not match current version ($MAJOR), skipping branch tag"
            fi
          else
            echo "::notice::Branch name '$TARGET_BRANCH' is not version-like, skipping branch tag"
          fi
        fi

        echo "exact_tag=$EXACT_TAG" >> "$GITHUB_OUTPUT"
        echo "branch_tag=$BRANCH_TAG" >> "$GITHUB_OUTPUT"
        echo "git_tags=$TAGS_CREATED" >> "$GITHUB_OUTPUT"

        {
          echo "### git-tag-builder"
          echo "- Target branch: \`$TARGET_BRANCH\`"
          if [ -n "$BRANCH_TAG" ]; then
            echo "- Branch tag: \`$BRANCH_TAG\`"
          fi
          echo "- Git tags calculated:"
          for tag in $TAGS_CREATED; do
            echo "  - \`$tag\`"
          done
        } >> "$GITHUB_STEP_SUMMARY"
