name: Version Reader
description: Read version information from Node.js package.json files, extract version patterns from branch names, or read latest version tag from target branch

inputs:
  type:
    description: "Source type to read version from. Supported values: nodejs, branch, target"
    required: true
  source-branch-name:
    description: "Source branch name to extract version from (required when type=branch)"
    required: false
    default: ''
  target-branch-name:
    description: "Target branch name to read latest tag from (required when type=target)"
    required: false
    default: ''

outputs:
  version:
    description: "Full version string with optional postfix (e.g., v1.0.1+1, 1.0.1)"
    value: ${{ steps.read.outputs.version }}
  version-short:
    description: "Clean semantic version without postfix (e.g., v1.0.1, 1.0.1)"
    value: ${{ steps.read.outputs.version_short }}

runs:
  using: "composite"
  steps:
    - name: Read version
      id: read
      shell: bash
      run: |
        set -euo pipefail

        TYPE="${{ inputs.type }}"

        if [[ "$TYPE" == "nodejs" ]]; then
          echo "::notice::Reading version from package.json"

          if [ ! -f "package.json" ]; then
            echo "::error::package.json not found in repository root"
            exit 1
          fi

          VERSION=$(node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const version = (pkg.version || '').toString().trim();
            if (!version) {
              console.error('No version field found in package.json');
              process.exit(1);
            }
            console.log(version);
          " 2>&1)

          if [ $? -ne 0 ]; then
            echo "::error::Failed to read version from package.json: $VERSION"
            exit 1
          fi

          echo "::notice::Read version from package.json: $VERSION"

        elif [[ "$TYPE" == "branch" ]]; then
          echo "::notice::Extracting version from branch name"

          BRANCH_NAME="${{ inputs.source-branch-name }}"

          if [[ -z "$BRANCH_NAME" ]]; then
            echo "::error::source-branch-name input is required when type=branch"
            exit 1
          fi

          echo "::notice::Branch name: $BRANCH_NAME"

          # Extract version pattern from branch name
          # Supports: v1.2.3, 1.2.3, release/v1.2.3, v1.2.3+build, v1.2, 1.2, etc.
          if [[ "$BRANCH_NAME" =~ ([vV]?)([0-9]+)\.([0-9]+)(\.([0-9]+))?(\+[^/]+)? ]]; then
            PREFIX="${BASH_REMATCH[1]}"
            MAJOR="${BASH_REMATCH[2]}"
            MINOR="${BASH_REMATCH[3]}"
            PATCH="${BASH_REMATCH[5]}"
            POSTFIX="${BASH_REMATCH[6]}"

            # Default patch to 0 if not provided
            if [[ -z "$PATCH" ]]; then
              PATCH="0"
              echo "::notice::Patch version not found in branch name, defaulting to 0"
            fi

            VERSION="${PREFIX}${MAJOR}.${MINOR}.${PATCH}${POSTFIX}"
            echo "::notice::Extracted version from branch name: $VERSION"
          else
            echo "::error::No valid version pattern found in branch name: $BRANCH_NAME"
            echo "::error::Expected patterns: v1.2.3, 1.2.3, release/v1.2.3, v1.2, etc."
            exit 1
          fi

        elif [[ "$TYPE" == "target" ]]; then
          echo "::notice::Reading latest version tag from target branch"

          TARGET_BRANCH="${{ inputs.target-branch-name }}"

          if [[ -z "$TARGET_BRANCH" ]]; then
            echo "::error::target-branch-name input is required when type=target"
            exit 1
          fi

          echo "::notice::Target branch: $TARGET_BRANCH"

          git fetch --tags --force >/dev/null 2>&1 || true

          LATEST_TAG=""
          if git rev-parse "origin/$TARGET_BRANCH" >/dev/null 2>&1; then
            RAW_TAGS=$(git tag --merged "origin/$TARGET_BRANCH" 2>/dev/null || true)

            SEMVER_TAGS=""
            if [ -n "$RAW_TAGS" ]; then
              while IFS= read -r TAG; do
                [ -z "$TAG" ] && continue

                if [[ "$TAG" =~ ^([vV]?)([0-9]+)\.([0-9]+)\.([0-9]+)(\+.+)?$ ]]; then
                  TAG_PREFIX="${BASH_REMATCH[1]}"
                  TAG_MAJOR="${BASH_REMATCH[2]}"
                  TAG_MINOR="${BASH_REMATCH[3]}"
                  TAG_PATCH="${BASH_REMATCH[4]}"

                  TAG_BASE="${TAG_MAJOR}.${TAG_MINOR}.${TAG_PATCH}"
                  SEMVER_TAGS+="$TAG_BASE\n"
                fi
              done <<< "$RAW_TAGS"
            fi

            if [ -n "$SEMVER_TAGS" ]; then
              LATEST_BASE=$(printf '%s\n' "$SEMVER_TAGS" | sed '/^$/d' | sort -V | tail -n1)
              # Get the original tag to preserve prefix and postfix
              LATEST_TAG=$(git tag --merged "origin/$TARGET_BRANCH" | grep -E "^[vV]?${LATEST_BASE}" | head -n1)
            fi
          else
            echo "::warning::Target branch origin/$TARGET_BRANCH not found"
          fi

          if [ -z "$LATEST_TAG" ]; then
            VERSION="0.0.0"
            echo "::notice::No tags found on target branch, using default: $VERSION"
          else
            VERSION="$LATEST_TAG"
            echo "::notice::Latest tag from target branch: $VERSION"
          fi

        else
          echo "::error::Unsupported type: $TYPE"
          echo "::error::Supported types: nodejs, branch, target"
          exit 1
        fi

        # Validate version matches supported patterns
        if [[ ! "$VERSION" =~ ^([vV]?)([0-9]+)\.([0-9]+)\.([0-9]+)(\+.+)?$ ]]; then
          echo "::error::Version does not match supported pattern: $VERSION"
          echo "::error::Expected format: [v]X.Y.Z[+postfix]"
          exit 1
        fi

        # Extract components for version-short
        if [[ "$VERSION" =~ ^([vV]?)([0-9]+\.[0-9]+\.[0-9]+)(\+.+)?$ ]]; then
          VERSION_SHORT="${BASH_REMATCH[1]}${BASH_REMATCH[2]}"
        else
          VERSION_SHORT="$VERSION"
        fi

        echo "version=$VERSION" >> "$GITHUB_OUTPUT"
        echo "version_short=$VERSION_SHORT" >> "$GITHUB_OUTPUT"

        echo "::notice::Version: $VERSION"
        echo "::notice::Version Short: $VERSION_SHORT"

        {
          echo "### version-reader"
          echo "- Type: $TYPE"
          if [[ "$TYPE" == "branch" ]]; then
            echo "- Branch name: $BRANCH_NAME"
          elif [[ "$TYPE" == "target" ]]; then
            echo "- Target branch: $TARGET_BRANCH"
          fi
          echo "- Version: $VERSION"
          echo "- Version Short: $VERSION_SHORT"
        } >> "$GITHUB_STEP_SUMMARY"
